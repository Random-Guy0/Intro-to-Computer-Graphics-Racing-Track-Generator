<html>

<head>
	<title></title>
</head>

<style>
	body {
		margin: 0;
	}

	canvas {
		width: 100%;
		height: 100%;
	}
</style>

<body>


	<style>
		body {
			font-family: Monospace;
			background-color: #000;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
		}
	</style>

	<div id="info">
		
	</div>

	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"cannon-es": "https://cdn.jsdelivr.net/gh/pmndrs/cannon-es@0.19.0/dist/cannon-es.js",
					"cannon-debug": "https://cdn.jsdelivr.net/gh/pmndrs/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"
				}
			}
		</script>
	<script src="jsm/CarControls.js" type="module"></script>

	<script type="module" src="jsm/carModelLoader.js"></script>
	<script src="jsm/dat.gui.min.js"></script>
	<!-- <script src="jsm/physics/cannon.js"></script> -->
	<script src="jsm/perlin.js"></script>
	<script type="module">
		// Imports
		import * as THREE from 'three';
		import * as CANNON from 'cannon-es'
		import CannonDebugger from 'cannon-debug'
		import Player from './jsm/testCar.js'
		import { OrbitControls } from './jsm/controls/OrbitControls.js';

		import { MTLLoader } from './jsm/loaders/MTLLoader.js';
		import { OBJLoader } from './jsm/loaders/OBJLoader.js';

		import CarControls from './jsm/CarControls.js';
		import Chunk from './jsm/Chunk.js'
		import ChunkSystem from './jsm/ChunkSystem.js'

		import * as CarModelLoader from './jsm/carModelLoader.js'

		var clock = new THREE.Clock();

		var physicsWorld = new CANNON.World();
		physicsWorld.gravity.set(0, -9.8, 0);
		physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
		physicsWorld.solver.iterations = 10000;
		//physicsWorld.allowSleep = true;

		//create the scene
		var scene = new THREE.Scene();
		var ratio = window.innerWidth / window.innerHeight;
		//create the perspective camera
		//for parameters see https://threejs.org/docs/#api/cameras/PerspectiveCamera
		var camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);

		//set the camera position
		camera.position.set(0, 10, 15);
		// and the direction
		camera.lookAt(0, 0, 1);

		//create the webgl renderer
		var renderer = new THREE.WebGLRenderer();

		//set the size of the rendering window
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		//add the renderer to the current document
		document.body.appendChild(renderer.domElement);

		// add the new control and link to the current camera to transform its position

		var controls = new OrbitControls(camera, renderer.domElement);

		// Debug
		const cannonDebugger = new CannonDebugger(scene, physicsWorld, {
			color: 0x000000,
		}) 

		//then add lighting
		//var cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 1);
		//cameralight.castShadow = true;
		//camera.add(cameralight);
		scene.add(camera);

		var directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
		directionalLight.position.set(10, 70, 10);
		directionalLight.castShadow = true;
		scene.add(directionalLight);

		var ambientlight = new THREE.AmbientLight(new THREE.Color(1,1,1),0.2);
  		scene.add(ambientlight);

		directionalLight.shadow.mapSize.width = 512;
		directionalLight.shadow.mapSize.height = 512;
		directionalLight.shadow.camera.near = 0.01;
		directionalLight.shadow.camera.far = 500;
		directionalLight.shadow.camera.top = 5;
		directionalLight.shadow.camera.bottom = -5;
		directionalLight.shadow.camera.left = -5;
		directionalLight.shadow.camera.right = 5;
		//const helper = new THREE.CameraHelper(directionalLight.shadow.camera)
		///scene.add(helper)

		//Add car to scene
		CarModelLoader.addCarToScene(5, scene);

		// Adjustable variables
		var carColourProperties = {
			body_colour: 0x000000,
			disk_colour: 0x000000,
			tyre_colour: 0x000000,
			wheel_colour: 0x000000,
			window_tint: 0x000000
		}

		var carPhysicsProperties = {
			move_speed: 1.5,
			turn_speed: 1.0
		}

		var resetCarPos = { reset_car: function()
		{
			carBody.chassisBody.angularVelocity = new CANNON.Vec3(0, 0, 0);
			carBody.chassisBody.linearVelocity = new CANNON.Vec3(0, 0, 0);
			carBody.chassisBody.quaternion.copy(new CANNON.Quaternion());
			carBody.chassisBody.position.y += 2;
		}};

		var worldProperties = {
			gravity: 9.8,	// Multiplied by -1
			background_colour: 0x87CEEB,
			fog_colour: 0x87CEEB,
			fog_near: 1,
			fog_far: 700
		}
		scene.background = new THREE.Color(worldProperties.background_colour)
		scene.fog = new THREE.Fog(worldProperties.fog_colour, worldProperties.fog_near, worldProperties.fog_far)

		var cameraProperties = {
			fov: 45
		}


		var guiBuilt = false			// Flag for when gui has been built

		var carControls;

		var meshes = [], bodies = [];

		var groundMat = new CANNON.Material();

		/* function createGround()
		{
			var geometry = new THREE.PlaneGeometry(1000, 1000, 128, 128);
			var material = new THREE.MeshLambertMaterial({color: 0x32a852});
			var terrain = new THREE.Mesh(geometry, material);
			terrain.rotation.x = -Math.PI / 2;
			scene.add(terrain);
			terrain.updateMatrixWorld();
	
			noise.seed(Math.random());
			var peak = 60;
			var smoothing = 300;
			var rawVertices = geometry.attributes.position.array;
			for(var i = 0; i <= rawVertices.length; i+=3)
			{
				rawVertices[i+2] = peak * noise.perlin2(rawVertices[i] / smoothing, rawVertices[i + 1] / smoothing);
			}
			geometry.attributes.position.needsUpdate = true;
			geometry.computeVertexNormals();
	
			//geometry = THREE.BufferGeometryUtils.mergeVertices(geometry);
	
			var position = geometry.attributes.position.array
	
			var rawFaces = 	geometry.index.array;
	
			var vertices = [];
			var faces = [];
	
			for(var i = 0; i < position.length; i += 3)
			{
				vertices.push(new CANNON.Vec3(position[i], position[i + 1], position[i + 2]));
			}
	
			
			for(var i = 0; i < rawFaces.length; i += 3)
			{
				faces.push(rawFaces[i], rawFaces[i + 1], rawFaces[i + 2]);
			}
	
			//var shape = new CANNON.ConvexPolyhedron(vertices, faces);
			//var shape = new CANNON.Trimesh(position, rawFaces);
			var shape = new CANNON.Box(new CANNON.Vec3(1000, 1, 1000));
	
			var groundBody = new CANNON.Body({
				mass: 0,
				material: groundMat
			})
			groundBody.addShape(shape);
			//groundBody.position.set(pos.x, pos.y, pos.z);
			physicsWorld.addBody(groundBody);
		}
		createGround(); */

		const seed = Math.random()
		// TEST CODE
		/* var chunk = new Chunk(0, 0, 100, 128, seed, scene, physicsWorld)
		var chunk = new Chunk(0, 1, 100, 128, seed, scene, physicsWorld)
		var chunk = new Chunk(1, 1, 100, 128, seed, scene, physicsWorld) */
		var peakHeight = 60;
		var terrainSmoothing = 300;
		var chunkSystem
		var chunkSystemFlag = false
		var car;
		var carBody;
		//var delta = new THREE.Quaternion();
		var wheels = [];
		var wheelBodies = [];
		var wheelMat;
		
		var lightOffset = new THREE.Vector3();

		//final update loop
		var MyUpdateLoop = function () {
			var deltaTime = clock.getDelta();

			if (carControls == null && scene.getObjectByName("Car") != null) {
				car = scene.getObjectByName("Car");
				directionalLight.target = car;
				lightOffset.subVectors(directionalLight.position, car.position);
				//console.log(car.isMesh);
				for(var i = 0; i < car.children.length; i++)
				{
					//console.log(car.children[i].isMesh);
					if(car.children[i].isMesh)
					{
						car.children[i].castShadow = true;
					}
				}
				//car.position.y += 5;
				//car.rotateY(-Math.PI / 2);
				car.add(camera);
				carControls = new CarControls(car, camera, carPhysicsProperties.move_speed, carPhysicsProperties.turn_speed, THREE, CANNON, physicsWorld, groundMat);
				carBody = carControls.createRigidBody();
				//meshes.push(car);
				//physicsWorld.addBody(body);
				//bodies.push(body);
				wheelBodies = carControls.wheelBodies;
				wheelMat = new THREE.MeshPhongMaterial(CarModelLoader.getMaterialsObject().tyre_colour);
				wheelMat.wireframe = true;
				for(var i = 0; i < wheelBodies.length; i++)
				{
					var wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 20);
					wheelGeometry.rotateX(-Math.PI / 2);
					var wheel = new THREE.Mesh(wheelGeometry, wheelMat);
					wheel.position.copy(wheelBodies[i].position);
					wheel.quaternion.copy(wheelBodies[i].quaternion);
					wheels.push(wheel);
					scene.add(wheel);
				}
				resetCarPos.reset_car();
			}
			else if (carControls != null) {
				if (!chunkSystemFlag) {
					chunkSystemFlag = true
					chunkSystem = new ChunkSystem(256, 257, 2, carControls, scene, physicsWorld, seed, peakHeight, terrainSmoothing)
				}
				chunkSystem.updateChunk(carControls)
				carControls.move();
				updateHud()
			}
			/* player.move()
			if (!chunkSystemFlag) {
				chunkSystemFlag = true
				chunkSystem = new ChunkSystem(50, 16, 2, player, scene, physicsWorld, seed)
			}
			chunkSystem.updateChunk(player) */

			updatePhysics(deltaTime);
			//cannonDebugger.update()

			updateCamera();

			//call the render with the scene and the camera
			renderer.render(scene, camera);

			controls.update();

			

			if (!guiBuilt) {
				if (CarModelLoader.matLoaded) {
					carColourProperties = CarModelLoader.getMaterialsObject()
					buildGUI()
				}
			}
			//finally perform a recoursive call to update again
			//this must be called because the mouse change the camera position
			requestAnimationFrame(MyUpdateLoop);
		};

		function updatePhysics(deltaTime) {
			physicsWorld.step(deltaTime);

			for (var i = 0; i < meshes.length; i++) {
				meshes[i].position.copy(bodies[i].position);
				meshes[i].quaternion.copy(bodies[i].quaternion);
			}

			if (car != null) {
				//delta = camera.quaternion;
				car.position.copy(carBody.chassisBody.position);
				car.quaternion.copy(carBody.chassisBody.quaternion);
				var newLightPos = new THREE.Vector3();
				newLightPos.addVectors(car.position, lightOffset);
				directionalLight.position.copy(newLightPos);
				
				for(var i = 0; i < wheelBodies.length; i++)
				{
					wheels[i].position.copy(wheelBodies[i].position);
					wheels[i].quaternion.copy(wheelBodies[i].quaternion);
				}
			}
		}

		function updateCamera() {
			if (car != null) {
				//camera.quaternion.copy(delta);
				camera.lookAt(car.position);
			}
		}

		requestAnimationFrame(MyUpdateLoop);

		//this fucntion is called when the window is resized
		var MyResize = function () {
			var width = window.innerWidth;
			var height = window.innerHeight;
			renderer.setSize(width, height);
			camera.aspect = width / height;
			camera.updateProjectionMatrix();
			renderer.render(scene, camera);
		};

		//link the resize of the window to the update of the camera
		window.addEventListener('resize', MyResize);

		const onKeyDown = (event) => {
			switch (event.keyCode) {
				//case 32:
				//CarModelLoader.updateCarMaterial(0xFF0000, 0xFFFFFF, 0xFFFFFF, 0x000000, 0xFFFFFF)
				case 82:
					resetCarPos.reset_car();
					break;
			}
		}
		window.addEventListener('keydown', onKeyDown, false)

		let seedHTML = ""
		var terrain_properties = {
			peak_height: peakHeight,
			terrain_smoothing: terrainSmoothing,
			terrain_seed: '',
			current_seed: seed,	// Current world seed, hidden value
			reset_terrain: function()
			{
				let terrainSeed = parseInt(terrain_properties.terrain_seed)
				if(isNaN(terrainSeed) || terrain_properties.terrain_seed == '') {
					terrainSeed = Math.random()
					terrain_properties.current_seed = terrainSeed
				}
				chunkSystem.removeAllChunks();
				resetCarPos.reset_car();
				carBody.chassisBody.position.y += 100;
				chunkSystem = new ChunkSystem(256, 257, 2, carControls, scene, physicsWorld, terrainSeed, peakHeight, terrainSmoothing);
			},
			get_seed: () => {
				navigator.clipboard.writeText(terrain_properties.current_seed);
				seedHTML = "<p>Seed Copied to clipboard ["+terrain_properties.current_seed+"]</p>"
			}
		};

		var gui
		var carColours
		var carPhysics
		var worldPropertyGUI
		var terrainPropertiesGUI
		const buildGUI = () => {
			gui = new dat.GUI()
			// Colours folder
			carColours = gui.addFolder('Colours')
			carColours.addColor(carColourProperties, 'body_colour').onChange(val => { CarModelLoader.updateCarMaterial(val, carColourProperties.disk_colour, carColourProperties.tyre_colour, carColourProperties.wheel_colour, carColourProperties.window_tint) }).name("Body Colour")
			carColours.addColor(carColourProperties, 'disk_colour').onChange(val => { CarModelLoader.updateCarMaterial(carColourProperties.body_colour, val, carColourProperties.tyre_colour, carColourProperties.wheel_colour, carColourProperties.window_tint) }).name("Brake disk Colour")
			carColours.addColor(carColourProperties, 'tyre_colour').onChange(val => { CarModelLoader.updateCarMaterial(carColourProperties.body_colour, carColourProperties.disk_colour, val, carColourProperties.wheel_colour, carColourProperties.window_tint); wheelMat.color.setHex(val); }).name("Tyre Colour")
			carColours.addColor(carColourProperties, 'wheel_colour').onChange(val => { CarModelLoader.updateCarMaterial(carColourProperties.body_colour, carColourProperties.disk_colour, carColourProperties.tyre_colour, val, carColourProperties.window_tint); }).name("Wheel Colour")
			carColours.addColor(carColourProperties, 'window_tint').onChange(val => { CarModelLoader.updateCarMaterial(carColourProperties.body_colour, carColourProperties.disk_colour, carColourProperties.tyre_colour, carColourProperties.wheel_colour, val) }).name("Window Colour")

			// Car Physics folder
			carPhysics = gui.addFolder('Car Physics')
			carPhysics.add(carPhysicsProperties, 'move_speed', 0.5, 7.5, 0.5).onChange(_ => carControls.setVariable(carPhysicsProperties)).name("Movement Speed")
			carPhysics.add(carPhysicsProperties, 'turn_speed', 0.05, 1, 0.05).onChange(_ => carControls.setVariable(carPhysicsProperties)).name("Turning speed")

			// World Property folder
			worldPropertyGUI = gui.addFolder('World Properties')
			worldPropertyGUI.add(worldProperties, 'gravity', 0.0, 20.0, 0.05).onChange(val => physicsWorld.gravity.set(0, -val, 0)).name("Gravity")
			worldPropertyGUI.addColor(worldProperties, 'background_colour').onChange(val => scene.background = new THREE.Color(val)).name("Background Colour")
			worldPropertyGUI.addColor(worldProperties, 'fog_colour').onChange(_ => scene.fog = new THREE.Fog(worldProperties.fog_colour, worldProperties.fog_near, worldProperties.fog_far)).name("Fog Colour")
			worldPropertyGUI.add(worldProperties, 'fog_near', 0, 1500, 1).onChange(_ => scene.fog = new THREE.Fog(worldProperties.fog_colour, worldProperties.fog_near, worldProperties.fog_far))
			worldPropertyGUI.add(worldProperties, 'fog_far', 10, 2000, 1).onChange(_ => scene.fog = new THREE.Fog(worldProperties.fog_colour, worldProperties.fog_near, worldProperties.fog_far))

			terrainPropertiesGUI = gui.addFolder('Terrain Properties');
			terrainPropertiesGUI.add(terrain_properties, 'peak_height').onChange(val => { peakHeight = val; }).name("Terrain Peak Height");
			terrainPropertiesGUI.add(terrain_properties, 'terrain_smoothing').onChange(val => { terrainSmoothing = val }).name("Terrain Smoothing");
			terrainPropertiesGUI.add(terrain_properties, 'terrain_seed').onChange(val => { terrain_properties.terrain_seed = val }).name("Seed");
			terrainPropertiesGUI.add(terrain_properties, 'reset_terrain').name("Reset Terrain");
			terrainPropertiesGUI.add(terrain_properties, 'get_seed').name("Get Seed");

			// Camera FOV
			gui.add(cameraProperties, 'fov', 25, 100).onChange(val => {
				camera.fov = val
				camera.updateProjectionMatrix();
			}).name("Field of View")

			gui.add(resetCarPos, 'reset_car').name("Reset car position");

			gui.open()
			guiBuilt = true
		}

		const handbrakeActiveColour = 'red'
		const handbrakeInactiveColour = '#69ff69'
		const infoEl = document.getElementById("info")
		const controlsHTML = `<p>Controls: WASD to move/steer the car, spacebar to toggle handbrake, R to reset car position</p>\n
		<p>Leave custom seed blank to generate new seed.</p>`
		const updateHud = () => {
			let speed = carControls.getSpeed()
			let handbrakeStatus = carControls.getBrakeStatus()
			let speedHTML = "<p>Speed: " + speed + "</p>"
			let handbrakeColour = 0x000000
			let handbrakeText = ""
			if(handbrakeStatus) {
				handbrakeColour = handbrakeActiveColour 
				handbrakeText = "Handbrake Active"
			}
			else {
				handbrakeColour = handbrakeInactiveColour
				handbrakeText = "Handbrake Inactive"
			}
			let handbrakeHTML = "<p style=\"color:" + handbrakeColour + ";\">" + handbrakeText + "</p>"
			infoEl.innerHTML = controlsHTML + "\n" + seedHTML + "\n" + speedHTML +"\n"+ handbrakeHTML
		}


	</script>
</body>

</html>